<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D 電荷與電場模擬器 (修正版)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #1a1a1a; color: white; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
        
        /* UI 介面層 */
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            pointer-events: auto;
            max-width: 320px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        #info-panel {
            position: absolute;
            bottom: 20px;
            left: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            pointer-events: none;
            font-size: 0.9em;
            max-width: 90vw;
        }

        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 0.85em; margin-bottom: 5px; color: #ccc; }
        input[type="number"], select {
            width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #444; background: #333; color: white;
            box-sizing: border-box;
        }
        button {
            width: 100%; padding: 10px; margin-top: 5px; cursor: pointer;
            background: #4a90e2; border: none; border-radius: 4px; color: white; font-weight: bold; font-size: 1em;
        }
        button.danger { background: #e24a4a; }
        button:active { transform: scale(0.98); }

        /* 手機版優化 */
        @media (max-width: 600px) {
            #ui-container {
                top: auto; bottom: 0; left: 0; right: 0;
                width: 100%; max-width: 100%;
                border-radius: 15px 15px 0 0;
                display: grid; 
                grid-template-columns: 1fr 1fr; 
                gap: 10px;
                padding: 15px;
                padding-bottom: 30px;
            }
            .full-width { grid-column: span 2; }
            #info-panel { top: 10px; bottom: auto; background: rgba(0,0,0,0.6); }
        }
    </style>
    <!-- 引入 Three.js -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>

    <div id="ui-container">
        <div class="control-group full-width">
            <label>操作模式</label>
            <select id="modeSelect">
                <option value="charge">放置電荷 (Source)</option>
                <option value="probe">放置觀測點 (Probe - 限一個)</option>
            </select>
        </div>
        <div class="control-group">
            <label>電荷量 (Q)</label>
            <input type="number" id="chargeValue" value="1" step="1">
        </div>
        <div class="control-group">
            <label>目前操作</label>
            <div style="font-size: 0.8em; color:#aaa; line-height:1.4;">
                點擊網格放置。<br>格線單位: 1
            </div>
        </div>
        <div class="control-group full-width">
            <button id="clearBtn" class="danger">清除場景</button>
        </div>
    </div>

    <div id="info-panel">
        <div id="statusText" style="font-weight: bold; margin-bottom:5px;">準備就緒</div>
        <div id="dataText" style="color: #4a90e2;"></div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 全域變數 ---
        let scene, camera, renderer, controls;
        let plane;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        
        // 資料儲存
        const charges = []; // 存放 Source 電荷
        let probe = null;   // 存放單一 Probe 物件
        
        const gridStep = 1; // 格線單位改為 1
        const k = 50;       // 視覺模擬係數

        // UI 元素
        const elMode = document.getElementById('modeSelect');
        const elCharge = document.getElementById('chargeValue');
        const elStatus = document.getElementById('statusText');
        const elData = document.getElementById('dataText');

        init();
        animate();

        function init() {
            // 1. 場景
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);

            // 2. 相機
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 15); // 拉遠一點因為格線變大了

            // 3. 渲染
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 4. 控制
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            // 5. 輔助網格 (大小 40, 分割 40 => 每一格是 1)
            const gridHelper = new THREE.GridHelper(40, 40, 0x888888, 0x333333);
            scene.add(gridHelper);

            // 座標軸
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);

            // 點擊判定平面
            const planeGeometry = new THREE.PlaneGeometry(100, 100);
            const planeMaterial = new THREE.MeshBasicMaterial({ visible: false });
            plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            scene.add(plane);

            // 光源 (讓球體有立體感)
            const ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // 6. 事件
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('pointerdown', onPointerDown);
            document.getElementById('clearBtn').addEventListener('click', clearAll);
        }

        function onPointerDown(event) {
            if(event.target !== renderer.domElement) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(plane);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                // 吸附邏輯：四雪五入到最近的整數 (因為 gridStep = 1)
                const x = Math.round(point.x);
                const z = Math.round(point.z);
                
                placeObject(new THREE.Vector3(x, 0, z));
            }
        }

        function placeObject(position) {
            const mode = elMode.value;
            const value = parseFloat(elCharge.value);

            // 檢查位置是否已有電荷 (避免重疊)
            for(let c of charges) {
                if(c.mesh.position.distanceTo(position) < 0.1) return;
            }
            if(probe && probe.mesh.position.distanceTo(position) < 0.1) return;

            // 幾何設定：球體小於格線 1 (設為 0.25)
            const geometry = new THREE.SphereGeometry(0.25, 32, 32);
            
            if (mode === 'probe') {
                // 如果已有 probe，先移除舊的
                if (probe) {
                    scene.remove(probe.mesh);
                    probe = null;
                }

                const material = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0x333300 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                scene.add(mesh);

                // 建立箭頭 (初始長度 0)
                const arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 0, 0xffff00);
                mesh.add(arrowHelper);

                probe = {
                    mesh: mesh,
                    type: 'probe',
                    arrow: arrowHelper,
                    force: new THREE.Vector3(), // 這裡代表電場 E
                    potential: 0
                };
                elStatus.textContent = `放置觀測點於 (${position.x}, 0, ${position.z})`;

            } else {
                // 放置電荷
                const color = value > 0 ? 0xff3333 : 0x3388ff;
                const material = new THREE.MeshPhongMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                scene.add(mesh);

                // 電荷光暈
                const light = new THREE.PointLight(color, 1, 4);
                mesh.add(light);

                // 電荷受力箭頭
                const arrowHelper = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 0, 0xffffff);
                mesh.add(arrowHelper);

                charges.push({
                    mesh: mesh,
                    value: value,
                    type: 'charge',
                    arrow: arrowHelper,
                    force: new THREE.Vector3(),
                    potential: 0
                });
                elStatus.textContent = `放置電荷 Q=${value} 於 (${position.x}, 0, ${position.z})`;
            }

            updatePhysics();
        }

        function clearAll() {
            charges.forEach(c => scene.remove(c.mesh));
            charges.length = 0;
            if (probe) {
                scene.remove(probe.mesh);
                probe = null;
            }
            elStatus.textContent = "場景已清除";
            elData.textContent = "";
        }

        function updatePhysics() {
            // 1. 重置數據
            charges.forEach(c => { c.force.set(0,0,0); c.potential = 0; });
            if(probe) { probe.force.set(0,0,0); probe.potential = 0; }

            let maxForceMag = 0;

            // 2. 計算電荷間的受力 (Source <-> Source)
            for (let i = 0; i < charges.length; i++) {
                const c1 = charges[i];
                for (let j = 0; j < charges.length; j++) {
                    if (i === j) continue;
                    const c2 = charges[j];
                    
                    const rVec = new THREE.Vector3().subVectors(c1.mesh.position, c2.mesh.position);
                    const dist = rVec.length();
                    if (dist < 0.1) continue;

                    // 庫倫力 F = k * q1 * q2 / r^2
                    const forceMag = (k * c1.value * c2.value) / (dist * dist);
                    const dir = rVec.normalize();
                    c1.force.add(dir.multiplyScalar(forceMag));
                    
                    // 電位疊加 (只計算別人對自己的)
                    c1.potential += (k * c2.value) / dist;
                }
                maxForceMag = Math.max(maxForceMag, c1.force.length());
            }

            // 3. 計算觀測點的電場 (Probe <-> Source)
            // 電場 E = k * Q / r^2 (相當於放置一個 +1 的測試電荷)
            if (probe) {
                for (let c of charges) {
                    const rVec = new THREE.Vector3().subVectors(probe.mesh.position, c.mesh.position);
                    const dist = rVec.length();
                    if (dist < 0.1) continue;

                    // 電場方向由 Source 指向 Probe (若 Source 為正)
                    const dir = rVec.normalize();
                    const eFieldMag = (k * 1 * c.value) / (dist * dist);
                    
                    probe.force.add(dir.multiplyScalar(eFieldMag));
                    probe.potential += (k * c.value) / dist;
                }
                // 將 Probe 的電場大小也納入縮放考量
                maxForceMag = Math.max(maxForceMag, probe.force.length());
            }

            // 4. 視覺化更新 (箭頭縮放)
            // 設定螢幕上箭頭的最大長度 (例如 2 格長)
            const MAX_VISUAL_LENGTH = 2.5; 
            
            // 輔助函式：更新單一物件的箭頭
            const updateArrow = (obj) => {
                const vec = obj.force;
                const mag = vec.length();
                if (mag > 0.01) {
                    obj.arrow.visible = true;
                    obj.arrow.setDirection(vec.clone().normalize());
                    
                    // 線性縮放： (目前值 / 最大值) * 最大顯示長度
                    let visualLen = (mag / maxForceMag) * MAX_VISUAL_LENGTH;
                    
                    // 避免太短看不到
                    if(visualLen < 0.3) visualLen = 0.3;
                    
                    // 箭頭參數: length, headLength, headWidth
                    obj.arrow.setLength(visualLen, visualLen * 0.25, visualLen * 0.15);
                } else {
                    obj.arrow.visible = false;
                }
            };

            charges.forEach(updateArrow);
            if (probe) updateArrow(probe);

            // 更新文字資訊
            if (probe) {
                elData.innerHTML = `觀測點數據:<br>電位 V ≈ ${probe.potential.toFixed(2)}<br>電場強度 |E| ≈ ${probe.force.length().toFixed(2)}`;
            } else if (charges.length > 0) {
                elData.textContent = `場景中有 ${charges.length} 個電荷`;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
